; generated by Component: ARM Compiler 5.99 update 4 (build 402) Tool: ArmCC [5b6802]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hid_transfer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hid_transfer.d --feedback=.\obj\NANO100B_ISP_HID_PB15.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\hid_transfer.crf ..\hid_transfer.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;144    extern __align(4) uint8_t response_buff[64];
;;;145    void EP2_Handler(void)  /* Interrupt IN handler */
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147        uint8_t *ptr;
;;;148        ptr = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
000002  4c06              LDR      r4,|L1.28|
000004  6820              LDR      r0,[r4,#0]
000006  4905              LDR      r1,|L1.28|
;;;149        /* Prepare the data for next HID IN transfer */
;;;150        USBD_MemCopy(ptr, response_buff, EP2_MAX_PKT_SIZE);
000008  2240              MOVS     r2,#0x40
00000a  31c0              ADDS     r1,r1,#0xc0           ;148
00000c  1840              ADDS     r0,r0,r1              ;148
00000e  4904              LDR      r1,|L1.32|
000010  f7fffffe          BL       USBD_MemCopy
;;;151        USBD_SET_PAYLOAD_LEN(EP2, EP2_MAX_PKT_SIZE);
000014  2040              MOVS     r0,#0x40
000016  6060              STR      r0,[r4,#4]
;;;152    }
000018  bd10              POP      {r4,pc}
;;;153    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40060040
                  |L1.32|
                          DCD      response_buff

                          AREA ||i.EP3_Handler||, CODE, READONLY, ALIGN=2

                  EP3_Handler PROC
;;;153    
;;;154    void EP3_Handler(void)  /* Interrupt OUT handler */
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156        uint8_t *ptr;
;;;157        /* Interrupt OUT */
;;;158        ptr = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
000002  4c07              LDR      r4,|L2.32|
000004  6920              LDR      r0,[r4,#0x10]
000006  4906              LDR      r1,|L2.32|
;;;159        USBD_MemCopy(usb_rcvbuf, ptr, EP3_MAX_PKT_SIZE);
000008  2240              MOVS     r2,#0x40
00000a  31c0              ADDS     r1,r1,#0xc0           ;158
00000c  1841              ADDS     r1,r0,r1              ;158
00000e  4805              LDR      r0,|L2.36|
000010  f7fffffe          BL       USBD_MemCopy
;;;160        bUsbDataReady = TRUE;
000014  4904              LDR      r1,|L2.40|
000016  2001              MOVS     r0,#1
000018  7008              STRB     r0,[r1,#0]
;;;161        USBD_SET_PAYLOAD_LEN(EP3, EP3_MAX_PKT_SIZE);
00001a  2040              MOVS     r0,#0x40
00001c  6160              STR      r0,[r4,#0x14]
;;;162    }
00001e  bd10              POP      {r4,pc}
;;;163    
                          ENDP

                  |L2.32|
                          DCD      0x40060040
                  |L2.36|
                          DCD      ||.bss||
                  |L2.40|
                          DCD      ||area_number.12||

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;197    
;;;198    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;199    {
;;;200        uint8_t buf[8];
;;;201        USBD_GetSetupPacket(buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;202    
;;;203        if (buf[0] & 0x80)   /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  0600              LSLS     r0,r0,#24
00000e  d405              BMI      |L3.28|
;;;204        {
;;;205            // Device to host
;;;206            switch (buf[1])
;;;207            {
;;;208            case GET_REPORT:
;;;209    
;;;210    //             {
;;;211    //                 break;
;;;212    //             }
;;;213            case GET_IDLE:
;;;214    
;;;215    //             {
;;;216    //                 break;
;;;217    //             }
;;;218            case GET_PROTOCOL:
;;;219    
;;;220    //            {
;;;221    //                break;
;;;222    //            }
;;;223            default:
;;;224            {
;;;225                /* Setup error, stall the device */
;;;226                USBD_SetStall(0);
;;;227                break;
;;;228            }
;;;229            }
;;;230        }
;;;231        else
;;;232        {
;;;233            // Host to device
;;;234            switch (buf[1])
000010  4668              MOV      r0,sp
000012  7840              LDRB     r0,[r0,#1]
000014  2809              CMP      r0,#9
000016  d005              BEQ      |L3.36|
000018  280a              CMP      r0,#0xa
00001a  d00f              BEQ      |L3.60|
                  |L3.28|
;;;235            {
;;;236            case SET_REPORT:
;;;237            {
;;;238                if (buf[3] == 3)
;;;239                {
;;;240                    /* Request Type = Feature */
;;;241                    USBD_SET_DATA1(EP1);
;;;242                    USBD_SET_PAYLOAD_LEN(EP1, 0);
;;;243                }
;;;244    
;;;245                break;
;;;246            }
;;;247    
;;;248            case SET_IDLE:
;;;249            {
;;;250                /* Status stage */
;;;251                USBD_SET_DATA1(EP0);
;;;252                USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;253                break;
;;;254            }
;;;255    
;;;256            case SET_PROTOCOL:
;;;257    
;;;258    //             {
;;;259    //                 break;
;;;260    //             }
;;;261            default:
;;;262            {
;;;263                // Stall
;;;264                /* Setup error, stall the device */
;;;265                USBD_SetStall(0);
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       USBD_SetStall
                  |L3.34|
;;;266                break;
;;;267            }
;;;268            }
;;;269        }
;;;270    }
000022  bd1c              POP      {r2-r4,pc}
                  |L3.36|
000024  4668              MOV      r0,sp                 ;238
000026  78c0              LDRB     r0,[r0,#3]            ;238
000028  2803              CMP      r0,#3                 ;238
00002a  d1fa              BNE      |L3.34|
00002c  4807              LDR      r0,|L3.76|
00002e  6b81              LDR      r1,[r0,#0x38]         ;241
000030  2280              MOVS     r2,#0x80              ;241
000032  4311              ORRS     r1,r1,r2              ;241
000034  6381              STR      r1,[r0,#0x38]         ;241
000036  2100              MOVS     r1,#0                 ;242
000038  6341              STR      r1,[r0,#0x34]         ;242
00003a  bd1c              POP      {r2-r4,pc}
                  |L3.60|
00003c  4803              LDR      r0,|L3.76|
00003e  6a81              LDR      r1,[r0,#0x28]         ;251
000040  2280              MOVS     r2,#0x80              ;251
000042  4311              ORRS     r1,r1,r2              ;251
000044  6281              STR      r1,[r0,#0x28]         ;251
000046  2100              MOVS     r1,#0                 ;252
000048  6241              STR      r1,[r0,#0x24]         ;252
00004a  bd1c              POP      {r2-r4,pc}
;;;271    
                          ENDP

                  |L3.76|
                          DCD      0x40060000

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;170      */
;;;171    void HID_Init(void)
000000  480c              LDR      r0,|L4.52|
;;;172    {
;;;173        /* Init setup packet buffer */
;;;174        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;175        USBD->BUFSEG = SETUP_BUF_BASE;
000002  2100              MOVS     r1,#0
000004  6181              STR      r1,[r0,#0x18]
;;;176        /*****************************************************/
;;;177        /* EP0 ==> control IN endpoint, address 0 */
;;;178        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  21ff              MOVS     r1,#0xff
000008  3141              ADDS     r1,r1,#0x41
00000a  6281              STR      r1,[r0,#0x28]
;;;179        /* Buffer range for EP0 */
;;;180        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000c  2108              MOVS     r1,#8
00000e  6201              STR      r1,[r0,#0x20]
;;;181        /* EP1 ==> control OUT endpoint, address 0 */
;;;182        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000010  22ff              MOVS     r2,#0xff
000012  3221              ADDS     r2,r2,#0x21
000014  6382              STR      r2,[r0,#0x38]
;;;183        /* Buffer range for EP1 */
;;;184        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000016  6301              STR      r1,[r0,#0x30]
;;;185        /*****************************************************/
;;;186        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;187        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | INT_IN_EP_NUM);
000018  4806              LDR      r0,|L4.52|
00001a  2141              MOVS     r1,#0x41
00001c  3040              ADDS     r0,r0,#0x40
00001e  6081              STR      r1,[r0,#8]
;;;188        /* Buffer range for EP2 */
;;;189        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
000020  2110              MOVS     r1,#0x10
000022  6001              STR      r1,[r0,#0]
;;;190        /* EP3 ==> Interrupt OUT endpoint, address 2 */
;;;191        USBD_CONFIG_EP(EP3, USBD_CFG_EPMODE_OUT | INT_OUT_EP_NUM);
000024  2122              MOVS     r1,#0x22
000026  6181              STR      r1,[r0,#0x18]
;;;192        /* Buffer range for EP3 */
;;;193        USBD_SET_EP_BUF_ADDR(EP3, EP3_BUF_BASE);
000028  2150              MOVS     r1,#0x50
00002a  6101              STR      r1,[r0,#0x10]
;;;194        /* trigger to receive OUT data */
;;;195        USBD_SET_PAYLOAD_LEN(EP3, EP3_MAX_PKT_SIZE);
00002c  2140              MOVS     r1,#0x40
00002e  6141              STR      r1,[r0,#0x14]
;;;196    }
000030  4770              BX       lr
;;;197    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x40060000

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;20     
;;;21     void USBD_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;22     {
;;;23         uint32_t u32IntSts = USBD_GET_INT_FLAG();
000002  4d35              LDR      r5,|L5.216|
000004  68ec              LDR      r4,[r5,#0xc]
;;;24         uint32_t u32State = USBD_GET_BUS_STATE();
000006  6868              LDR      r0,[r5,#4]
000008  0706              LSLS     r6,r0,#28
00000a  0f36              LSRS     r6,r6,#28
;;;25     
;;;26     //------------------------------------------------------------------
;;;27         if (u32IntSts & USBD_INTSTS_FLDET)
00000c  0760              LSLS     r0,r4,#29
00000e  d50b              BPL      |L5.40|
;;;28         {
;;;29             // Floating detect
;;;30             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000010  2004              MOVS     r0,#4
000012  60e8              STR      r0,[r5,#0xc]
;;;31     
;;;32             if (USBD_IS_ATTACHED())
000014  6868              LDR      r0,[r5,#4]
000016  06c0              LSLS     r0,r0,#27
;;;33             {
;;;34                 /* USB Plug In */
;;;35                 USBD_ENABLE_USB();
;;;36             }
;;;37             else
;;;38             {
;;;39                 /* USB Un-plug */
;;;40                 USBD_DISABLE_USB();
000018  6828              LDR      r0,[r5,#0]
00001a  d502              BPL      |L5.34|
00001c  210f              MOVS     r1,#0xf               ;35
00001e  4308              ORRS     r0,r0,r1              ;35
000020  e001              B        |L5.38|
                  |L5.34|
000022  0840              LSRS     r0,r0,#1
000024  0040              LSLS     r0,r0,#1
                  |L5.38|
000026  6028              STR      r0,[r5,#0]            ;35
                  |L5.40|
;;;41             }
;;;42         }
;;;43     
;;;44     //------------------------------------------------------------------
;;;45         if (u32IntSts & USBD_INTSTS_BUS)
000028  07e0              LSLS     r0,r4,#31
00002a  d015              BEQ      |L5.88|
;;;46         {
;;;47             /* Clear event flag */
;;;48             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
00002c  2001              MOVS     r0,#1
00002e  60e8              STR      r0,[r5,#0xc]
;;;49     
;;;50             if (u32State & USBD_STATE_USBRST)
000030  07f0              LSLS     r0,r6,#31
000032  d005              BEQ      |L5.64|
;;;51             {
;;;52                 /* Bus reset */
;;;53                 USBD_ENABLE_USB();
000034  6828              LDR      r0,[r5,#0]
000036  210f              MOVS     r1,#0xf
000038  4308              ORRS     r0,r0,r1
00003a  6028              STR      r0,[r5,#0]
;;;54                 USBD_SwReset();
00003c  f7fffffe          BL       USBD_SwReset
                  |L5.64|
;;;55             }
;;;56     
;;;57             if (u32State & USBD_STATE_SUSPEND)
000040  07b0              LSLS     r0,r6,#30
000042  d503              BPL      |L5.76|
;;;58             {
;;;59                 /* Enable USB but disable PHY */
;;;60                 USBD_DISABLE_PHY();
000044  6828              LDR      r0,[r5,#0]
000046  2102              MOVS     r1,#2
000048  4388              BICS     r0,r0,r1
00004a  6028              STR      r0,[r5,#0]
                  |L5.76|
;;;61             }
;;;62     
;;;63             if (u32State & USBD_STATE_RESUME)
00004c  0770              LSLS     r0,r6,#29
00004e  d503              BPL      |L5.88|
;;;64             {
;;;65                 /* Enable USB and enable PHY */
;;;66                 USBD_ENABLE_USB();
000050  6828              LDR      r0,[r5,#0]
000052  210f              MOVS     r1,#0xf
000054  4308              ORRS     r0,r0,r1
000056  6028              STR      r0,[r5,#0]
                  |L5.88|
;;;67             }
;;;68         }
;;;69     
;;;70     //------------------------------------------------------------------
;;;71         if (u32IntSts & USBD_INTSTS_USB)
000058  07a0              LSLS     r0,r4,#30
00005a  d53b              BPL      |L5.212|
;;;72         {
;;;73             // USB event
;;;74             if (u32IntSts & USBD_INTSTS_SETUP)
00005c  2c00              CMP      r4,#0
00005e  da0b              BGE      |L5.120|
;;;75             {
;;;76                 // Setup packet
;;;77                 /* Clear event flag */
;;;78                 USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
000060  2001              MOVS     r0,#1
000062  07c0              LSLS     r0,r0,#31
000064  60e8              STR      r0,[r5,#0xc]
;;;79                 /* Clear the data IN/OUT ready flag of control end-points */
;;;80                 USBD_STOP_TRANSACTION(EP0);
000066  6aa9              LDR      r1,[r5,#0x28]
000068  0c00              LSRS     r0,r0,#16
00006a  4301              ORRS     r1,r1,r0
00006c  62a9              STR      r1,[r5,#0x28]
;;;81                 USBD_STOP_TRANSACTION(EP1);
00006e  6ba9              LDR      r1,[r5,#0x38]
000070  4301              ORRS     r1,r1,r0
000072  63a9              STR      r1,[r5,#0x38]
;;;82                 USBD_ProcessSetupPacket();
000074  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L5.120|
;;;83             }
;;;84     
;;;85             // EP events
;;;86             if (u32IntSts & USBD_INTSTS_EP0)
000078  03e0              LSLS     r0,r4,#15
00007a  d504              BPL      |L5.134|
;;;87             {
;;;88                 /* Clear event flag */
;;;89                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
00007c  2001              MOVS     r0,#1
00007e  0400              LSLS     r0,r0,#16
000080  60e8              STR      r0,[r5,#0xc]
;;;90                 // control IN
;;;91                 USBD_CtrlIn();
000082  f7fffffe          BL       USBD_CtrlIn
                  |L5.134|
;;;92             }
;;;93     
;;;94             if (u32IntSts & USBD_INTSTS_EP1)
000086  03a0              LSLS     r0,r4,#14
000088  d504              BPL      |L5.148|
;;;95             {
;;;96                 /* Clear event flag */
;;;97                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
00008a  2001              MOVS     r0,#1
00008c  0440              LSLS     r0,r0,#17
00008e  60e8              STR      r0,[r5,#0xc]
;;;98                 // control OUT
;;;99                 USBD_CtrlOut();
000090  f7fffffe          BL       USBD_CtrlOut
                  |L5.148|
;;;100            }
;;;101    
;;;102            if (u32IntSts & USBD_INTSTS_EP2)
000094  0360              LSLS     r0,r4,#13
000096  d502              BPL      |L5.158|
;;;103            {
;;;104                /* Clear event flag */
;;;105                USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
000098  2001              MOVS     r0,#1
00009a  0480              LSLS     r0,r0,#18
00009c  60e8              STR      r0,[r5,#0xc]
                  |L5.158|
;;;106                // Interrupt IN
;;;107    //          EP2_Handler();
;;;108            }
;;;109    
;;;110            if (u32IntSts & USBD_INTSTS_EP3)
00009e  0320              LSLS     r0,r4,#12
0000a0  d504              BPL      |L5.172|
;;;111            {
;;;112                /* Clear event flag */
;;;113                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
0000a2  2001              MOVS     r0,#1
0000a4  04c0              LSLS     r0,r0,#19
0000a6  60e8              STR      r0,[r5,#0xc]
;;;114                // Interrupt OUT
;;;115                EP3_Handler();
0000a8  f7fffffe          BL       EP3_Handler
                  |L5.172|
;;;116            }
;;;117    
;;;118            if (u32IntSts & USBD_INTSTS_EP4)
0000ac  02e0              LSLS     r0,r4,#11
0000ae  d502              BPL      |L5.182|
;;;119            {
;;;120                /* Clear event flag */
;;;121                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
0000b0  2001              MOVS     r0,#1
0000b2  0500              LSLS     r0,r0,#20
0000b4  60e8              STR      r0,[r5,#0xc]
                  |L5.182|
;;;122            }
;;;123    
;;;124            if (u32IntSts & USBD_INTSTS_EP5)
0000b6  02a0              LSLS     r0,r4,#10
0000b8  d502              BPL      |L5.192|
;;;125            {
;;;126                /* Clear event flag */
;;;127                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
0000ba  2001              MOVS     r0,#1
0000bc  0540              LSLS     r0,r0,#21
0000be  60e8              STR      r0,[r5,#0xc]
                  |L5.192|
;;;128            }
;;;129    
;;;130            if (u32IntSts & USBD_INTSTS_EP6)
0000c0  0260              LSLS     r0,r4,#9
0000c2  d502              BPL      |L5.202|
;;;131            {
;;;132                /* Clear event flag */
;;;133                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
0000c4  2001              MOVS     r0,#1
0000c6  0580              LSLS     r0,r0,#22
0000c8  60e8              STR      r0,[r5,#0xc]
                  |L5.202|
;;;134            }
;;;135    
;;;136            if (u32IntSts & USBD_INTSTS_EP7)
0000ca  0220              LSLS     r0,r4,#8
0000cc  d502              BPL      |L5.212|
;;;137            {
;;;138                /* Clear event flag */
;;;139                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
0000ce  2001              MOVS     r0,#1
0000d0  05c0              LSLS     r0,r0,#23
0000d2  60e8              STR      r0,[r5,#0xc]
                  |L5.212|
;;;140            }
;;;141        }
;;;142    }
0000d4  bd70              POP      {r4-r6,pc}
;;;143    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L5.216|
                          DCD      0x40060000

                          AREA ||i.USBD_MemCopy||, CODE, READONLY, ALIGN=1

                  USBD_MemCopy PROC
;;;393      */
;;;394    static __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
000000  e003              B        |L6.10|
                  |L6.2|
;;;395    {
;;;396        while (size--) *dest++ = *src++;
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
000006  1c40              ADDS     r0,r0,#1
000008  1c49              ADDS     r1,r1,#1
                  |L6.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L6.2|
;;;397    }
00000e  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;407     */
;;;408    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  b510              PUSH     {r4,lr}
;;;409    {
;;;410        uint32_t u32CfgAddr;
;;;411        uint32_t u32Cfg;
;;;412        int i;
;;;413    
;;;414        for (i=0; i<USBD_MAX_EP; i++)
000002  2100              MOVS     r1,#0
                  |L7.4|
;;;415        {
;;;416            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000004  4b08              LDR      r3,|L7.40|
000006  010a              LSLS     r2,r1,#4
000008  18d3              ADDS     r3,r2,r3
;;;417            u32Cfg = *((__IO uint32_t *) (u32CfgAddr));
00000a  681a              LDR      r2,[r3,#0]
;;;418    
;;;419            if((u32Cfg & 0xf) == epnum)
00000c  0714              LSLS     r4,r2,#28
00000e  0f24              LSRS     r4,r4,#28
000010  4284              CMP      r4,r0
000012  d104              BNE      |L7.30|
;;;420            {
;;;421                *((__IO uint32_t *) (u32CfgAddr)) = (u32Cfg | USBD_CFG_SSTALL);
000014  2001              MOVS     r0,#1
000016  0240              LSLS     r0,r0,#9
000018  4302              ORRS     r2,r2,r0
00001a  601a              STR      r2,[r3,#0]
;;;422                break;
;;;423            }
;;;424        }
;;;425    }
00001c  bd10              POP      {r4,pc}
                  |L7.30|
00001e  1c49              ADDS     r1,r1,#1
000020  2908              CMP      r1,#8                 ;414
000022  dbef              BLT      |L7.4|
000024  bd10              POP      {r4,pc}
;;;426    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40060028

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usb_rcvbuf
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  g_u8EP2Ready
000000  00                DCB      0x00

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  bUsbDataReady
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\hid_transfer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_hid_transfer_c_6dbc9832____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_hid_transfer_c_6dbc9832____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_hid_transfer_c_6dbc9832____REVSH|
#line 402
|__asm___14_hid_transfer_c_6dbc9832____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
